# Thread

code—byte

## 线程本质和java线程类

1.线程本质是一个运行一段代码（code—byte）的过程，java线程只是一个线程说明类，当java线程类start方法被调用时，系统才会创建一个真正的线程，并把Thread类里面的run()中的代码交给cpu运行。多线程的时候，jvm怎么跟踪每一个线程的执行呢？jvm会给每一个线程一个方法调用栈(method-call stack)，调用栈除了可以跟踪线程的执行还可以跟踪本地变量（**怎么跟踪本地变量**）。

2.为什么suspend()，和resume()方法会破坏对象

3.构造函数 线程名字

4.sleep方法，线程变为阻塞状态，让出CPU使用权,在一个线程睡眠的时候，该线程可能被另外一个线程中断，所以sleep需要抛出异常（InterruptedException），
线程进入阻塞状态，

5.jion方法，在当前线程里面调用其他线程的jion方法，会让当前线程等待你目标线程执行结束，才继续往下面执行，或者指定jion的时间，到时见后，线程继续运行,其实就是isAlive和while或者sleep的封装，线程调用自己的jion方法，会导致线程永远等待下去

6.守护线程，当应用程序只有守护线程在运行的时候，jvm就会退出，不管守护线程有没有运行完，设置线程为守护线程，setDeadmon(true);

7.线程名字，用来标记线程，系统会自动生成，也可以自己设置，	如果在线程object已经start以后，调用setDeamon方法会抛出 IllegalThreadStateException，

8.对于java线程来说，只有哦一个线程在运行run()中的时候，isAlive才会放回true，其他时间都返回false，线程调用自己的isAlice没有意义，因为一定会放回false，

9.Runnable 接口，补充了当对象已经继承了其他类的时候，不能够在继续使用线程的缺点。

10.synchronized
什么可以当做线程锁？（个人理解是：只要是当前线程可以得到的东西都可以当做一个锁的标记。）
同步中的this锁 ，死锁和性能
线程a需要线程b的锁才能继续运行，同时线程b需要线程a的锁才能继续运行，java优化了同步性能，释放锁和分配锁是一个消耗资源的过程。

11.当两个线程需要同一个锁的时候，jvm会让先进来的线程获取锁，后面的线程需要等待前一个线程释放锁之后才能获取锁，当两个线程想要获取的不是一个锁的时候，不会造成阻塞。

12.为了避免不同步，选择适用于所有相关的线程的对象当锁。这样一来，这些线程竞争以获取相同的对象的锁，而只有一次一个线程可以获得锁

13.与类和实例字段变量相比，线程不能共享本地变量和参数。原因是：本地变量和参数分配一个线程的方法调用堆栈。其结果是，每一个线程接收它自己那些变量的副本。相反，线程可以共享类字段和实例字段因为那些变量不上一个线程的方法调用堆栈分配。相反，他们在共享堆中分配内存，作为类（类字段）或对象（实例字段）的一部分。

注：Java的类型，只有长整型和双精度浮点变量容易出现不一致的情况。为什么？ 32位JVM通常访问一个64位长整型变量或在两个相邻的32位步骤的64位双精度浮点变量。一个线程可以完成的第一步，然后等待另一个线程执行这两个步骤。然后，第一线程可能醒，并完成第二步骤，产生与来自第一或第二个线程的值不同的值的变量。其结果是，如果至少一个线程可以修改任何一个长整型变量或一个双精度浮点变量，即读和/或修改该变量必须使用同步所有线程连续访问的变量。

14.java的同步机制立足于监视器和锁的概念。显示器看作围绕一个关键代码部分的保护包装和锁作为一个软件实体，一个监视器使用，以防止多个线程进入监视器。我们的想法是这样的：当一个线程想进入一个监视器守卫关键代码段，该线程必须获得与对象相关联的锁，与显示器的同事。 （每个对象都有其自己的锁）。如果其他线程持有锁，JVM会强迫请求线程与监视器/锁有关的等候区等待。当在显示屏中的线程释放锁时，JVM将删除显示器的等候区等待的线程，并允许线程获得锁并继续显示器的关键代码部分。

15.holdslock
指示当前线程是否具有指定对象的监视器锁定。
参数
对象测试的对象为监视器锁
返回
如果当前线程具有指定对象的监视器锁定;否则为false

16.同步类方法可以调用一个对象的同步方法或使用对象锁定一个synchronized块。在这种情况下，一个线程最初获得同步类方法的类锁，随后获取对象的对象锁。因此，一个同步类方法调用同步实例方法也获得两个锁。

17.线程的时序安排，因为一个处理器是被多个线程共享的，所以线程调度决定了线程。java的线程调度是取决于java所在的平台，java本身是没有线程调度的。所以在多平台下面保存相同的线程调度是很重要的。

问题1.java到底有没有自己的线程调度
问题2.优先级高的线程是不是会一直占用cpu

18.绿色线程调度，所有的线程都有自己的优先级，优先级高的先运行，当优先级高的线程进入阻塞状态的时候（比如读取操作，等待数据 ），jvm会启动轮循机制，这时可能将cpu分配给低优先级线程，这时如果高优先级线程需要的数据过来了，想要运行高优先级线程，也需要等到jvm下一个轮循操作。（**？因为java不是实时操作系统，所以不用担心，这样会造成问题？**）

19.优先反转优先级持有高优先级线程需要的锁，结果导致高优先级线程必须等待低优先级线程运行结束，这叫优先反转,jvm解决优先反转的方式是，比如：当优先级为3的线程持有了锁，一个优先级为9的线程去请求锁得时候，jvm会暂时将优先级为3的线程的优先级设置为请求锁的线程的优先级 9，直到线程3释放锁，它的优先级会被恢复。在线程3运行期间，如果一个线程结束阻塞，即使它的优先级大于3，也需要等待线程3运行结束。

20.本地线程调度有额外字节：时间切边的概念。时间片解决线程等待，通过优先级来分配时间片，是的低优先级线程也有机会运行（本地线程调度和green线程调度会不会有冲突），时间切片可以防止相同优先级的线程出现处理器饥饿，时间切片给相等优先级线程相同量的时间来运行，当一个线程的切片时间到了之后，调度器会调度另一个线程运行，除非有更高优先级的线程进来。同时为了防止低优先级线程饿死，对于长时间没有运行的线程，系统(比如windows)会临时提高低优先级线程的优先级，当线程运行，就会自动衰减该线程的优先级。

21.设置优先级setPriority，如果设置的值不是最高优先级和最低优先级中间的值，会抛出一个异常，IllegalArgumentException

22.yield()


如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。

当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。

优先级高的线程竞争到对象锁的概率大，假若某线程没有竞争到该对象锁，它还会留在锁池中，唯有线程再次调用 wait()方法，它才会重新回到等待池中。而竞争到对象锁的线程则继续往下执行，直到执行完了 synchronized 代码块，它会释放掉该对象锁，这时锁池中的线程会继续竞争该对象锁。
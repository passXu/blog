---
layout: post
title:  "java虚拟机"
date:   2017-09-7 10:10 +0800
categories: java jvm
catalog:    true
excerpt: java内存管理
tags:
    - jvm
    - 内存管理
---
# java虚拟机

## java虚拟机的内存管理

jvm将其从系统申请的内存空间划分为5个区域，这5个区域的职能以及jvm对这5个区域的管理，即是java主要的内存管理。5个区域如下图

![](/rikka/2017/09/java_memory_fivearea.png)

### java虚拟机栈

我更喜欢把这个称为指令队列(感觉jvm也遵循冯 ·诺伊曼体系结构)，队列里面存放一条条指令(栈帧)，每执行完一条指令(方法)，pc指向下一条指令(栈帧)，直到执行完所有的指令(栈帧)。当一个线程运行完所有的方法后，线程结束销毁，指令队列也销毁。栈顶的栈帧叫`当前栈`，所关联的方法为`当前方法`。程序编译时，`每个栈帧的局部变量表的大小，操作数栈的深度已经完全确定了`(`方法的参数是未知的，为啥局部变量表的大小就确定了呢`)，因此一个栈帧的大小不会受到程序运行期变量数据的影响，只取决于虚拟机的实现(似懂非的)。

#### 指令(栈帧)组成

##### 局部变量表

存放`基本数据类型`，`reference`，`returnaddress`,局部变量表内存空间编译期间就已经完全确定。

##### 操作数栈

操作数栈，也称为操作栈，操作数栈的最大深度是编译器确定的。32位数据类型占用的栈深度是1，64位数据类型占用的栈深度是2。当一个方法开始执行的时候，这个栈是空的，当指令字节码执行的时候，会向这个栈写入或提取数据。`java虚拟机的解释执行引擎被称为，“基于栈的执行引擎”，这里的栈值得就是操作数栈，android虚拟机是基于寄存器的。基于寄存器的栈特点是速度快但是移植性差，基于操作数栈的则于此相反。`

##### 动态链接

每个栈帧都持有一个方法区内栈对应数据结构方法的引用。持有这个引用的原因是为了支持方法调用过程中的动态链接(看不懂)。Class文件的常量池中，存在大量的`符号引用`，字节码中的方法调用指令就以方法的`符号引用`来作为参数。

这些`符号引用`一部分在类加载阶段或第一次使用时转化为直接引用(final，staticd域等)，这叫静态链接，另一部分在运行期间转化为直接引用，这称为动态链接。

##### 方法返回地址

一个方法执行结束有两种情况，第一种是方法遇到任何返回指令，另一种是出现方法内未处理的异常，不管哪一种结束方法的方式，这个方法执行结束之后需要返回到方法调用处，程序才能继续执行.方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。

一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能保存了这个计数器值，而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出站，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，如果有返回值，则把它压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令（可是还是不懂returnaddress干嘛的，还是说只有有了这个地址才能完成方法的正常退出与方法执行结果交付）。

##### 额外附加信息(？)

### 程序计数器

`每个线程独有一个程序计数器`，控制指令的执行流程。是唯一一个不会抛出oom异常的区域。

### 堆

存放对象的实例和数组，cg的主要对象，堆的内存在物理上不要求连续，逻辑上连续即可（`其他区域内存在物理上也是连续的?`）,

### 方法区

保存数据结构模型(数据结构，还有方法字节码)，常量，静态对象,即时编译器产生的代码等数据。Java虚拟机规范把方法区描述为Java堆的一个逻辑部分，而且它和Java Heap一样不需要连续的内存，可以选择固定大小或可扩展，另外，虚拟机规范允许该区域可以选择不实现垃圾回收。

相对而言，垃圾收集行为在这个区域比较少出现。该区域的内存回收目标主要针是对废弃常量的和无用类的回收。运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。

根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。

## 内存溢出

内存溢出测试，如下图
![](/rikka/2017/09/java_oom_test.png)

`值得注意的是，在多线程情况下，给每个线程栈分配的空间越大越容易出现内存溢出`操作系统为每个进程分配的内存是有限制的，虚拟机提供了参数来控制Java堆和方法区这两部分内存的最大值，忽略掉程序计数器消耗的内存（很小），以及进程本身消耗的内存，剩下的内存便给了虚拟机栈和本地方法栈，每个线程分配到的栈容量越大，可以建立的线程数量自然就越少。因此，如果是建立过多的线程导致的内存溢出，在不能减少线程数的情况下，就只能通过减少最大堆和每个线程的栈容量来换取更多的线程。

另外，由于Java堆内也可能发生内存泄露（Memory Leak），这里简要说明一下内存泄露和内存溢出的区别：

内存泄露是指分配出去的内存没有被回收回来，由于失去了对该内存区域的控制，因而造成了资源的浪费。Java中一般不会产生内存泄露，因为有垃圾回收器自动回收垃圾，但这也不绝对，当我们new了对象，并保存了其引用，但是后面一直没用它，而垃圾回收器又不会去回收它，这边会造成内存泄露，

内存溢出是指程序所需要的内存超出了系统所能分配内存（包括动态扩展）的上限。

## 对象实例化过程分析

实例化一个对象的时候，内存的变化`Object obj = new Object();`

运行这一行代码后，首先`指定队列`中当前栈的局部变量表会创建一个obj的reference，堆区会创建一个Object实例并持有方法区内Object类数据模型（类方法，父类，实现的接口，等）的地址信息。

另外java中的reference类型，java并没有规定reference指向实例的具体方法，因此不同虚拟机有不同的方法，主流的方法有两种，

通过句柄池：`句柄池是堆区内的一块区域，用来映射reference与堆实例的地址，这样reference不需要直接指向堆中实例的具体地址，只需要指向句柄池，通过句柄池映射实例的真实地址`，如下图：

![](/rikka/2017/09/java_memory_jubingchi.png)

直接指向实例：顾名思义，reference直接指向堆中实例,如下图：

![](/rikka/2017/09/java_memory_directpointer.png)

这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference中存放的是稳定的句柄地址，在对象呗移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。使用直接指针访问方式的最大好处是速度快，它节省了一次指针定位的时间开销。目前Java默认使用的HotSpot虚拟机采用的便是是第二种方式进行对象访问的。
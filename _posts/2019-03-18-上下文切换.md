---
layout: post
title:  "上下文切换"
date:   2019-03-15 10:10 +0800
categories: android 笔记
catalog: true
excerpt:
tags:
    - java
    - 系统
---

# 上下文切换

到底什么是上下文切换，cpu时间片轮转的时候，也会有上下文切换，所以理解的上下文切换应该就是指保存当前状态，切换到其他程序，然后其他程序执行完之后，取出状态，恢复状态继续上次的执行，到这里很好理解，可是为什么java中synchronized关键字，还有锁会导致上下文切换，线程的状态变化属于上下文切换么

进程上下文切换，线程上下文切换，由于进程和线程都有各自私有的东西，所以切换的时候，私有部分数据都必须保存起来，上下文切换应该就是值，保存私有数据的操作。上下文切换的开销应该就是指，保存和恢复这些数据所带来性能影响。可是正常时间片轮转也会带来上下文切换，

## linux上下文切换，以及切换类型

进程上下文切换（相关内容系统调用，系统调用会导致上下文切换）

线程上下文切换

中断上下文切换

[链接](..\rikka\webprint\深入理解Linux的CPU上下文切换.html)

## 相关知识并发（来自java并发编程的艺术）

锁的拥有者可以理解为线程

避免死锁，使用trylock 定时锁

`本文将深入分析在硬件层面上Intel处理器是如何实现volatile的，通过深入分析帮助我们正确地使用volatile变量。`怎么看起来java中的锁命令，是cpu级别的命令

monitorenter monitorexit 和 monitor（java中即使对象头）

锁能升级但是不能降级 无锁 偏向锁（没有竞争时类似与。无锁状态，偏向锁撤销时有消耗） 轻量级（自旋，自旋转过多升级重量级，自旋不会导致线程block，但是会使用cpu） 重量级，不能降级为了提高获取和释放锁的效率

原子操作 aba问题 ， 只能保证单个对象原子操作

JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环
CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时
候使用循环CAS释放锁。

顺序一致性，程序多次执行结果一样，为同步的java程序不保证顺序一致性，正确同步的程序能保证，顺序一致性。

java线程间通信是隐式的

重排序
编译器冲排序 volivate （i++不是原子操作）
cpu重排序 volivate转化为内存屏障
内存系统重排序（使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。）
as-if-serial 重排序不能影响单线程执行结果，但是可能会影响多线程执行结果。


happen-before阐释内存可见性，一个操作对另一个操作可见，前一个操作happen-before前一个操作

程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
volatile变量规则：对一个volatile域的写，happens-before于任意后续对这volatile域的读。
传递性：如果A happens-before B，且B happens-before C，那么A happens-before 
C

一个happens-before规则对应于一个或多个编译器和处理器重排序规则。对
于Java程序员来说，happens-before规则简单易懂，它避免Java程序员为了理解JMM提供的内存
可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法

aqs 实现lock的基本，内部有一个fifo队列

blockqueue 多用于生产者消费者情况

fork/join框架 ， 应用将大任务分割成不相关的小任务，最后将每个小任务的结果汇总成大任务。

原子操，作类，原子操作数组原子操作基本数据类型

## 问题来了还是没搞清楚，锁为什么会导致上下文切换

想了想应该是，当前线程想获取锁结果获取不到，所以只能把cpu时间让出去，导致线程上下文切换，

~~~txt
引起线程上下文切换的原因对于我们经常使用的抢占式操作系统而言，引起线程上下文切换的原因大概有以下几种：
1.当前执行任务的时间片用完之后，系统CPU正常调度下一个任务
2.当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务多个任务抢占锁资源，
3.当前任务没有抢到锁资源，被调度器挂起，继续下一任务
4.用户代码挂起当前任务，让出CPU时间
5.硬件中断

作者：dubx
链接：https://zhuanlan.zhihu.com/p/40473047
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~

如何减少上下文切换

~~~txt
1.无锁并发编程。多线程竞争时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash取模分段，不同的线程处理不同段的数据
2.CAS算法,Java的Atomic包使用CAS算法来更新数据，而不需要加锁
3.使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态
4.协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换

作者：dubx
链接：https://zhuanlan.zhihu.com/p/40473047
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
~~~